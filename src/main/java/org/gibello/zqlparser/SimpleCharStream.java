/* Generated By:JavaCC: Do not edit this line. SimpleCharStream.java Version 4.0 */
package org.gibello.zqlparser;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.UnsupportedEncodingException;

/**
 * An implementation of interface CharStream, where the stream is assumed to contain only ASCII characters (without
 * unicode processing).
 * 
 * @author Generated by JavaCC, Automated
 */
public class SimpleCharStream {

	/**
	 * Static flag.
	 */
	public static final boolean	STATIC_FLAG		= false;

	/**
	 * Buffer size.
	 */
	int							bufsize;

	/**
	 * Available chars.
	 */
	int							available;

	/**
	 * Token begins.
	 */
	int							tokenBegin;

	/**
	 * Buffer position.
	 */
	public int					bufpos			= -1;

	/**
	 * Buffer line.
	 */
	protected int				bufline[];

	/**
	 * Buffer column.
	 */
	protected int				bufcolumn[];

	/**
	 * Column pos.
	 */
	protected int				column			= 0;

	/**
	 * Line pos.
	 */
	protected int				line			= 1;

	/**
	 * Previous char is CR.
	 */
	protected boolean			prevCharIsCR	= false;

	/**
	 * Previous char is LF.
	 */
	protected boolean			prevCharIsLF	= false;

	/**
	 * Input stream.
	 */
	protected Reader			inputStream;

	/**
	 * Buffer.
	 */
	protected char[]			buffer;

	/**
	 * Maximum next char indent.
	 */
	protected int				maxNextCharInd	= 0;

	/**
	 * Chars in buffer.
	 */
	protected int				inBuf			= 0;

	/**
	 * Table size.
	 */
	protected int				tabSize			= 8;

	/**
	 * Sets the table size.
	 * 
	 * @param tableSize
	 *            the table size.
	 */
	protected void setTabSize(final int tableSize) {
		this.tabSize = tableSize;
	}

	/**
	 * Returns the table size.
	 * 
	 * @return the table size.
	 */
	protected int getTabSize() {
		return this.tabSize;
	}

	/**
	 * Expand buffer.
	 * 
	 * @param wrapAround
	 *            wrap around.
	 */
	protected void expandBuffer(final boolean wrapAround) {
		final char[] newbuffer = new char[this.bufsize + 2048];
		final int[] newbufline = new int[this.bufsize + 2048];
		final int[] newbufcolumn = new int[this.bufsize + 2048];

		// try {
		if (wrapAround) {
			System.arraycopy(this.buffer, this.tokenBegin, newbuffer, 0, this.bufsize - this.tokenBegin);
			System.arraycopy(this.buffer, 0, newbuffer, this.bufsize - this.tokenBegin, this.bufpos);
			this.buffer = newbuffer;

			System.arraycopy(this.bufline, this.tokenBegin, newbufline, 0, this.bufsize - this.tokenBegin);
			System.arraycopy(this.bufline, 0, newbufline, this.bufsize - this.tokenBegin, this.bufpos);
			this.bufline = newbufline;

			System.arraycopy(this.bufcolumn, this.tokenBegin, newbufcolumn, 0, this.bufsize - this.tokenBegin);
			System.arraycopy(this.bufcolumn, 0, newbufcolumn, this.bufsize - this.tokenBegin, this.bufpos);
			this.bufcolumn = newbufcolumn;

			this.bufpos += this.bufsize - this.tokenBegin;
			this.maxNextCharInd = this.bufpos;
		} else {
			System.arraycopy(this.buffer, this.tokenBegin, newbuffer, 0, this.bufsize - this.tokenBegin);
			this.buffer = newbuffer;

			System.arraycopy(this.bufline, this.tokenBegin, newbufline, 0, this.bufsize - this.tokenBegin);
			this.bufline = newbufline;

			System.arraycopy(this.bufcolumn, this.tokenBegin, newbufcolumn, 0, this.bufsize - this.tokenBegin);
			this.bufcolumn = newbufcolumn;

			this.bufpos -= this.tokenBegin;
			this.maxNextCharInd = this.bufpos;
		}
		// TODO check if try/catch is needed.
		// } catch (final Throwable t) {
		// throw new Error(t.getMessage());
		// }

		this.bufsize += 2048;
		this.available = this.bufsize;
		this.tokenBegin = 0;
	}

	/**
	 * Fill buffer.
	 * 
	 * @throws IOException
	 *             an input/output exception.
	 */
	protected void fillBuff() throws IOException {
		if (this.maxNextCharInd == this.available) {
			if (this.available == this.bufsize) {
				if (this.tokenBegin > 2048) {
					this.bufpos = this.maxNextCharInd = 0;
					this.available = this.tokenBegin;
				} else {
					if (this.tokenBegin < 0) {
						this.bufpos = this.maxNextCharInd = 0;
					} else {
						this.expandBuffer(false);
					}
				}
			} else {
				if (this.available > this.tokenBegin) {
					this.available = this.bufsize;
				} else {
					if ((this.tokenBegin - this.available) < 2048) {
						this.expandBuffer(true);
					} else {
						this.available = this.tokenBegin;
					}
				}
			}
		}

		int i;
		try {

			i = this.inputStream.read(this.buffer, this.maxNextCharInd, this.available - this.maxNextCharInd);
			if (i == -1) {
				this.inputStream.close();
				throw new java.io.IOException();
			} else {
				this.maxNextCharInd += i;
			}
			return;
		} catch (final IOException e) {
			--this.bufpos;
			this.backup(0);
			if (this.tokenBegin == -1) {
				this.tokenBegin = this.bufpos;
			}
			throw e;
		}
	}

	/**
	 * Begin token.
	 * 
	 * @return the token.
	 * @throws IOException
	 *             the input/output exception.
	 */
	public char beginToken() throws IOException {
		this.tokenBegin = -1;
		final char c = this.readChar();
		this.tokenBegin = this.bufpos;

		return c;
	}

	/**
	 * Update line and column.
	 * 
	 * @param character
	 *            the character to be updated.
	 */
	protected void updateLineColumn(final char character) {
		this.column++;

		if (this.prevCharIsLF) {
			this.prevCharIsLF = false;
			this.column = 1;
			this.line += this.column;
		} else
			if (this.prevCharIsCR) {
				this.prevCharIsCR = false;
				if (character == '\n') {
					this.prevCharIsLF = true;
				} else {
					this.column = 1;
					this.line += this.column;
				}
			}

		switch (character) {
			case '\r':
				this.prevCharIsCR = true;
				break;
			case '\n':
				this.prevCharIsLF = true;
				break;
			case '\t':
				this.column--;
				this.column += this.tabSize - (this.column % this.tabSize);
				break;
			default:
				break;
		}

		this.bufline[this.bufpos] = this.line;
		this.bufcolumn[this.bufpos] = this.column;
	}

	/**
	 * Read character.
	 * 
	 * @return the character.
	 * @throws IOException
	 *             the input/output exception.
	 */
	public char readChar() throws IOException {

		char result;

		if (this.inBuf > 0) {
			--this.inBuf;

			if (++this.bufpos == this.bufsize) {
				this.bufpos = 0;
			}

			result = this.buffer[this.bufpos];
		}

		if (++this.bufpos >= this.maxNextCharInd) {
			this.fillBuff();
		}

		result = this.buffer[this.bufpos];

		this.updateLineColumn(result);
		return result;
	}

	/**
	 * @deprecated the getColumn method is deprecated.
	 * @java.lang.Deprecated the getColumn method is deprecated.
	 * @see #getEndColumn
	 * @return the column id.
	 */
	public final int getColumn() {
		return this.bufcolumn[this.bufpos];
	}

	/**
	 * @deprecated this method is deprecated.
	 * @java.lang.Deprecated this method is deprecated.
	 * @see #getEndLine
	 * @return the line id.
	 */
	public int getLine() {
		return this.bufline[this.bufpos];
	}

	/**
	 * Gets the end column.
	 * 
	 * @return the index of the end column.
	 */
	public int getEndColumn() {
		return this.bufcolumn[this.bufpos];
	}

	/**
	 * Gets the end line.
	 * 
	 * @return the index of the end line.
	 */
	public int getEndLine() {
		return this.bufline[this.bufpos];
	}

	/**
	 * Gets the starting column.
	 * 
	 * @return the index of the starting column.
	 */
	public int getBeginColumn() {
		return this.bufcolumn[this.tokenBegin];
	}

	/**
	 * Gets the starting line.
	 * 
	 * @return the index of the starting line.
	 */
	public int getBeginLine() {
		return this.bufline[this.tokenBegin];
	}

	/**
	 * Backup method.
	 * 
	 * @param amount
	 *            the amount top backup.
	 */
	public void backup(final int amount) {

		this.inBuf += amount;
		this.bufpos -= amount;
		if (this.bufpos < 0) {
			this.bufpos += this.bufsize;
		}
	}

	/**
	 * Returns the char stream.
	 * 
	 * @param dstream
	 *            the reader stream.
	 * @param startline
	 *            the index of the starting line.
	 * @param startcolumn
	 *            the index of the starting column.
	 * @param buffersize
	 *            the buffersize.
	 */
	public SimpleCharStream(final Reader dstream, final int startline, final int startcolumn, final int buffersize) {
		this.inputStream = dstream;
		this.line = startline;
		this.column = startcolumn - 1;

		this.available = buffersize;
		this.bufsize = buffersize;
		this.buffer = new char[buffersize];
		this.bufline = new int[buffersize];
		this.bufcolumn = new int[buffersize];
	}

	/**
	 * Returns the char stream.
	 * 
	 * @param dstream
	 *            the reader stream.
	 * @param startline
	 *            the index of the starting line.
	 * @param startcolumn
	 *            the index of the starting column.
	 */
	public SimpleCharStream(final Reader dstream, final int startline, final int startcolumn) {
		this(dstream, startline, startcolumn, 4096);
	}

	/**
	 * Returns the char stream.
	 * 
	 * @param dstream
	 *            the reader stream.
	 */
	public SimpleCharStream(final Reader dstream) {
		this(dstream, 1, 1, 4096);
	}

	/**
	 * Reinitialisation method.
	 * 
	 * @param dstream
	 *            the reader stream.
	 * @param startline
	 *            the index of the starting line.
	 * @param startcolumn
	 *            the index of the starting column.
	 * @param buffersize
	 *            the buffer size.
	 */
	public void reInit(final Reader dstream, final int startline, final int startcolumn, final int buffersize) {
		this.inputStream = dstream;
		this.line = startline;
		this.column = startcolumn - 1;

		if (this.buffer == null || buffersize != this.buffer.length) {
			this.available = buffersize;
			this.bufsize = buffersize;
			this.buffer = new char[buffersize];
			this.bufline = new int[buffersize];
			this.bufcolumn = new int[buffersize];
		}
		this.prevCharIsLF = false;
		this.prevCharIsCR = false;
		this.tokenBegin = 0;
		this.inBuf = 0;
		this.maxNextCharInd = 0;
		this.bufpos = -1;
	}

	/**
	 * Reinitalisation method.
	 * 
	 * @param dstream
	 *            the reader stream.
	 * @param startline
	 *            the index of the starting line.
	 * @param startcolumn
	 *            the index of the starting column.
	 */
	public void reInit(final Reader dstream, final int startline, final int startcolumn) {
		this.reInit(dstream, startline, startcolumn, 4096);
	}

	/**
	 * Reinitialisation method.
	 * 
	 * @param dstream
	 *            the reader stream.
	 */
	public void reInit(final Reader dstream) {
		this.reInit(dstream, 1, 1, 4096);
	}

	/**
	 * Constructor.
	 * 
	 * @param dstream
	 *            the input stream.
	 * @param encoding
	 *            the encoding.
	 * @param startline
	 *            the index of the starting line.
	 * @param startcolumn
	 *            the index of the starting column.
	 * @param buffersize
	 *            the buffer size.
	 * @throws UnsupportedEncodingException
	 *             the unsupported encoding exception.
	 */
	public SimpleCharStream(final InputStream dstream, final String encoding, final int startline,
			final int startcolumn, final int buffersize) throws UnsupportedEncodingException {
		this(getStreamReaderFromInputStreamAndEncoding(dstream, encoding), startline, startcolumn, buffersize);
	}

	/**
	 * Returns an input stream reader.
	 * 
	 * @param dstream
	 *            the input stream.
	 * @param encoding
	 *            the encoding.
	 * @return the input stream reader.
	 * @throws UnsupportedEncodingException
	 *             the unsupported encoding exception.
	 */
	private static InputStreamReader getStreamReaderFromInputStreamAndEncoding(final InputStream dstream,
			final String encoding) throws UnsupportedEncodingException {
		InputStreamReader reader;

		if (encoding == null) {
			reader = new InputStreamReader(dstream);
		} else {
			reader = new InputStreamReader(dstream, encoding);
		}
		return reader;
	}

	/**
	 * Constructor.
	 * 
	 * @param dstream
	 *            the input stream.
	 * @param startline
	 *            the index of the starting line.
	 * @param startcolumn
	 *            the index of the starting column.
	 * @param buffersize
	 *            the buffer size.
	 */
	public SimpleCharStream(final InputStream dstream, final int startline, final int startcolumn, final int buffersize) {
		this(new InputStreamReader(dstream), startline, startcolumn, buffersize);
	}

	/**
	 * Constructor.
	 * 
	 * @param dstream
	 *            the input stream.
	 * @param encoding
	 *            the encoding.
	 * @param startline
	 *            the index of the starting line.
	 * @param startcolumn
	 *            the index of the starting column.
	 * @throws UnsupportedEncodingException
	 *             the unsupported encoding exception.
	 */
	public SimpleCharStream(final InputStream dstream, final String encoding, final int startline, final int startcolumn) throws UnsupportedEncodingException {
		this(dstream, encoding, startline, startcolumn, 4096);
	}

	/**
	 * Constructor.
	 * 
	 * @param dstream
	 *            the input stream.
	 * @param startline
	 *            the index of the starting line.
	 * @param startcolumn
	 *            the index of the starting column.
	 */
	public SimpleCharStream(final InputStream dstream, final int startline, final int startcolumn) {
		this(dstream, startline, startcolumn, 4096);
	}

	/**
	 * Constructor.
	 * 
	 * @param dstream
	 *            the input stream.
	 * @param encoding
	 *            the encoding.
	 * @throws UnsupportedEncodingException
	 *             the unsupported encoding exception.
	 */
	public SimpleCharStream(final InputStream dstream, final String encoding) throws UnsupportedEncodingException {
		this(dstream, encoding, 1, 1, 4096);
	}

	/**
	 * Constructor.
	 * 
	 * @param dstream
	 *            the input stream.
	 */
	public SimpleCharStream(final InputStream dstream) {
		this(dstream, 1, 1, 4096);
	}

	/**
	 * Reinitialisation method.
	 * 
	 * @param dstream
	 *            the input stream.
	 * @param encoding
	 *            the encoding.
	 * @param startline
	 *            the index of the starting line.
	 * @param startcolumn
	 *            the index of the starting column.
	 * @param buffersize
	 *            the buffer size.
	 * @throws UnsupportedEncodingException
	 *             the unsupported encoding exception.
	 */
	public void reInit(final InputStream dstream, final String encoding, final int startline, final int startcolumn,
			final int buffersize) throws UnsupportedEncodingException {
		this.reInit(getStreamReaderFromInputStreamAndEncoding(dstream, encoding), startline, startcolumn, buffersize);
	}

	/**
	 * Reinitialisation method.
	 * 
	 * @param dstream
	 *            the input stream.
	 * @param startline
	 *            the index of the starting line.
	 * @param startcolumn
	 *            the index of the starting column.
	 * @param buffersize
	 *            the buffer size.
	 */
	public void reInit(final InputStream dstream, final int startline, final int startcolumn, final int buffersize) {
		this.reInit(new InputStreamReader(dstream), startline, startcolumn, buffersize);
	}

	/**
	 * Reinitialisation method.
	 * 
	 * @param dstream
	 *            the input stream.
	 * @param encoding
	 *            the encoding.
	 * @throws UnsupportedEncodingException
	 *             the unsupported encoding exception.
	 */
	public void reInit(final InputStream dstream, final String encoding) throws UnsupportedEncodingException {
		this.reInit(dstream, encoding, 1, 1, 4096);
	}

	/**
	 * Reinitialisation method.
	 * 
	 * @param dstream
	 *            the input stream.
	 */
	public void reInit(final InputStream dstream) {
		this.reInit(dstream, 1, 1, 4096);
	}

	/**
	 * Reinitialisation method.
	 * 
	 * @param dstream
	 *            the input stream.
	 * @param encoding
	 *            the encoding.
	 * @param startline
	 *            the index of the starting line.
	 * @param startcolumn
	 *            the index of the starting column.
	 * @throws UnsupportedEncodingException
	 *             the unsupported encoding exception.
	 */
	public void reInit(final InputStream dstream, final String encoding, final int startline, final int startcolumn)
			throws UnsupportedEncodingException {
		this.reInit(dstream, encoding, startline, startcolumn, 4096);
	}

	/**
	 * Reinitialisation method.
	 * 
	 * @param dstream
	 *            then input stream.
	 * @param startline
	 *            the index of the starting line.
	 * @param startcolumn
	 *            the index of the starting column.
	 */
	public void reInit(final InputStream dstream, final int startline, final int startcolumn) {
		this.reInit(dstream, startline, startcolumn, 4096);
	}

	/**
	 * Get image.
	 * 
	 * @return the image.
	 */
	public String getImage() {
		String result;
		if (this.bufpos >= this.tokenBegin) {
			result = new String(this.buffer, this.tokenBegin, this.bufpos - this.tokenBegin + 1);
		} else {
			result = new String(this.buffer, this.tokenBegin, this.bufsize - this.tokenBegin)
					+ new String(this.buffer, 0, this.bufpos + 1);
		}

		return result;
	}

	/**
	 * Gets the suffix.
	 * 
	 * @param length
	 *            the length.
	 * @return the suffix.
	 */
	public char[] getSuffix(final int length) {
		final char[] ret = new char[length];

		if ((this.bufpos + 1) >= length) {
			System.arraycopy(this.buffer, this.bufpos - length + 1, ret, 0, length);
		} else {
			System.arraycopy(this.buffer, this.bufsize - (length - this.bufpos - 1), ret, 0, length - this.bufpos - 1);
			System.arraycopy(this.buffer, 0, ret, length - this.bufpos - 1, this.bufpos + 1);
		}

		return ret;
	}

	/**
	 * Clear method.
	 */
	public void clearBuffer() {
		this.buffer = null;
		this.bufline = null;
		this.bufcolumn = null;
	}

	/**
	 * Method to adjust line and column numbers for the start of a token.
	 * 
	 * @param line
	 *            the new starting line index.
	 * @param newCol
	 *            the new starting column index.
	 */
	public void adjustBeginLineColumn(final int line, final int newCol) {
		int start = this.tokenBegin;
		int len;
		int newLine = line;

		if (this.bufpos >= this.tokenBegin) {
			len = this.bufpos - this.tokenBegin + this.inBuf + 1;
		} else {
			len = this.bufsize - this.tokenBegin + this.bufpos + 1 + this.inBuf;
		}

		int i = 0;
		int j = 0;
		int k = 0;
		int nextColDiff = 0;
		int columnDiff = 0;

		j = start % this.bufsize;
		k = ++start % this.bufsize;
		while (i < len && this.bufline[j] == this.bufline[k]) {
			this.bufline[j] = newLine;
			nextColDiff = columnDiff + this.bufcolumn[k] - this.bufcolumn[j];
			this.bufcolumn[j] = newCol + columnDiff;
			columnDiff = nextColDiff;
			i++;
		}

		if (i < len) {
			this.bufline[j] = newLine++;
			this.bufcolumn[j] = newCol + columnDiff;

			while (i++ < len) {
				j = start % this.bufsize;
				k = ++start % this.bufsize;
				if (this.bufline[j] != this.bufline[k]) {
					this.bufline[j] = newLine++;
				} else {
					this.bufline[j] = newLine;
				}
			}
		}

		this.line = this.bufline[j];
		this.column = this.bufcolumn[j];
	}

}
