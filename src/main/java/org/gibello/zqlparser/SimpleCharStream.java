/* Generated By:JavaCC: Do not edit this line. SimpleCharStream.java Version 4.0 */
package org.gibello.zqlparser;

import java.io.IOException;
import java.io.Reader;

/**
 * An implementation of interface CharStream, where the stream is assumed to contain only ASCII characters (without
 * unicode processing).
 * 
 * @author Generated by JavaCC, Automated
 */
public class SimpleCharStream {

	/**
	 * Static flag.
	 */
	public static final boolean	STATIC_FLAG		= false;

	/**
	 * Buffer size.
	 */
	int							bufsize;

	/**
	 * Available chars.
	 */
	int							available;

	/**
	 * Token begins.
	 */
	int							tokenBegin;

	/**
	 * Buffer position.
	 */
	public int					bufpos			= -1;

	/**
	 * Buffer line.
	 */
	protected int				bufline[];

	/**
	 * Buffer column.
	 */
	protected int				bufcolumn[];

	/**
	 * Column pos.
	 */
	protected int				column			= 0;

	/**
	 * Line pos.
	 */
	protected int				line			= 1;

	/**
	 * Previous char is CR.
	 */
	protected boolean			prevCharIsCR	= false;

	/**
	 * Previous char is LF.
	 */
	protected boolean			prevCharIsLF	= false;

	/**
	 * Input stream.
	 */
	protected Reader			inputStream;

	/**
	 * Buffer.
	 */
	protected char[]			buffer;

	/**
	 * Maximum next char indent.
	 */
	protected int				maxNextCharInd	= 0;

	/**
	 * Chars in buffer.
	 */
	protected int				inBuf			= 0;

	/**
	 * Table size.
	 */
	protected int				tabSize			= 8;

	/**
	 * Sets the table size.
	 * 
	 * @param tableSize
	 *            the table size.
	 */
	protected void setTabSize(final int tableSize) {
		this.tabSize = tableSize;
	}

	/**
	 * Returns the table size.
	 * 
	 * @return the table size.
	 */
	protected int getTabSize() {
		return this.tabSize;
	}

	/**
	 * Expand buffer.
	 * 
	 * @param wrapAround
	 *            wrap around.
	 */
	protected void expandBuffer(final boolean wrapAround) {
		final char[] newbuffer = new char[this.bufsize + 2048];
		final int[] newbufline = new int[this.bufsize + 2048];
		final int[] newbufcolumn = new int[this.bufsize + 2048];

		// try {
		if (wrapAround) {
			System.arraycopy(this.buffer, this.tokenBegin, newbuffer, 0, this.bufsize - this.tokenBegin);
			System.arraycopy(this.buffer, 0, newbuffer, this.bufsize - this.tokenBegin, this.bufpos);
			this.buffer = newbuffer;

			System.arraycopy(this.bufline, this.tokenBegin, newbufline, 0, this.bufsize - this.tokenBegin);
			System.arraycopy(this.bufline, 0, newbufline, this.bufsize - this.tokenBegin, this.bufpos);
			this.bufline = newbufline;

			System.arraycopy(this.bufcolumn, this.tokenBegin, newbufcolumn, 0, this.bufsize - this.tokenBegin);
			System.arraycopy(this.bufcolumn, 0, newbufcolumn, this.bufsize - this.tokenBegin, this.bufpos);
			this.bufcolumn = newbufcolumn;

			this.bufpos += this.bufsize - this.tokenBegin;
			this.maxNextCharInd = this.bufpos;
		} else {
			System.arraycopy(this.buffer, this.tokenBegin, newbuffer, 0, this.bufsize - this.tokenBegin);
			this.buffer = newbuffer;

			System.arraycopy(this.bufline, this.tokenBegin, newbufline, 0, this.bufsize - this.tokenBegin);
			this.bufline = newbufline;

			System.arraycopy(this.bufcolumn, this.tokenBegin, newbufcolumn, 0, this.bufsize - this.tokenBegin);
			this.bufcolumn = newbufcolumn;

			this.bufpos -= this.tokenBegin;
			this.maxNextCharInd = this.bufpos;
		}
		// TODO check if try/catch is needed.
		// } catch (final Throwable t) {
		// throw new Error(t.getMessage());
		// }

		this.bufsize += 2048;
		this.available = this.bufsize;
		this.tokenBegin = 0;
	}

	/**
	 * Fill buffer.
	 * 
	 * @throws IOException
	 *             an input/output exception.
	 */
	protected void fillBuff() throws IOException {
		if (this.maxNextCharInd == this.available) {
			if (this.available == this.bufsize) {
				if (this.tokenBegin > 2048) {
					this.bufpos = this.maxNextCharInd = 0;
					this.available = this.tokenBegin;
				} else {
					if (this.tokenBegin < 0) {
						this.bufpos = this.maxNextCharInd = 0;
					} else {
						this.expandBuffer(false);
					}
				}
			} else {
				if (this.available > this.tokenBegin) {
					this.available = this.bufsize;
				} else {
					if ((this.tokenBegin - this.available) < 2048) {
						this.expandBuffer(true);
					} else {
						this.available = this.tokenBegin;
					}
				}
			}
		}

		int i;
		try {
			if ((i = inputStream.read(buffer, maxNextCharInd, available - maxNextCharInd)) == -1) {
				inputStream.close();
				throw new java.io.IOException();
			} else
				maxNextCharInd += i;
			return;
		} catch (java.io.IOException e) {
			--bufpos;
			backup(0);
			if (tokenBegin == -1) tokenBegin = bufpos;
			throw e;
		}
	}

	public char BeginToken() throws java.io.IOException {
		tokenBegin = -1;
		char c = readChar();
		tokenBegin = bufpos;

		return c;
	}

	protected void UpdateLineColumn(char c) {
		column++;

		if (prevCharIsLF) {
			prevCharIsLF = false;
			line += (column = 1);
		} else
			if (prevCharIsCR) {
				prevCharIsCR = false;
				if (c == '\n') {
					prevCharIsLF = true;
				} else
					line += (column = 1);
			}

		switch (c) {
			case '\r':
				prevCharIsCR = true;
				break;
			case '\n':
				prevCharIsLF = true;
				break;
			case '\t':
				column--;
				column += (tabSize - (column % tabSize));
				break;
			default:
				break;
		}

		bufline[bufpos] = line;
		bufcolumn[bufpos] = column;
	}

	public char readChar() throws java.io.IOException {
		if (inBuf > 0) {
			--inBuf;

			if (++bufpos == bufsize) bufpos = 0;

			return buffer[bufpos];
		}

		if (++bufpos >= maxNextCharInd) fillBuff();

		char c = buffer[bufpos];

		UpdateLineColumn(c);
		return (c);
	}

	/**
	 * @deprecated
	 * @see #getEndColumn
	 */

	public int getColumn() {
		return bufcolumn[bufpos];
	}

	/**
	 * @deprecated
	 * @see #getEndLine
	 */

	public int getLine() {
		return bufline[bufpos];
	}

	public int getEndColumn() {
		return bufcolumn[bufpos];
	}

	public int getEndLine() {
		return bufline[bufpos];
	}

	public int getBeginColumn() {
		return bufcolumn[tokenBegin];
	}

	public int getBeginLine() {
		return bufline[tokenBegin];
	}

	public void backup(int amount) {

		inBuf += amount;
		if ((bufpos -= amount) < 0) bufpos += bufsize;
	}

	public SimpleCharStream(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {
		inputStream = dstream;
		line = startline;
		column = startcolumn - 1;

		available = bufsize = buffersize;
		buffer = new char[buffersize];
		bufline = new int[buffersize];
		bufcolumn = new int[buffersize];
	}

	public SimpleCharStream(java.io.Reader dstream, int startline, int startcolumn) {
		this(dstream, startline, startcolumn, 4096);
	}

	public SimpleCharStream(java.io.Reader dstream) {
		this(dstream, 1, 1, 4096);
	}

	public void ReInit(java.io.Reader dstream, int startline, int startcolumn, int buffersize) {
		inputStream = dstream;
		line = startline;
		column = startcolumn - 1;

		if (buffer == null || buffersize != buffer.length) {
			available = bufsize = buffersize;
			buffer = new char[buffersize];
			bufline = new int[buffersize];
			bufcolumn = new int[buffersize];
		}
		prevCharIsLF = prevCharIsCR = false;
		tokenBegin = inBuf = maxNextCharInd = 0;
		bufpos = -1;
	}

	public void ReInit(java.io.Reader dstream, int startline, int startcolumn) {
		ReInit(dstream, startline, startcolumn, 4096);
	}

	public void ReInit(java.io.Reader dstream) {
		ReInit(dstream, 1, 1, 4096);
	}

	public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline, int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException {
		this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream,
				encoding), startline, startcolumn, buffersize);
	}

	public SimpleCharStream(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {
		this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
	}

	public SimpleCharStream(java.io.InputStream dstream, String encoding, int startline, int startcolumn) throws java.io.UnsupportedEncodingException {
		this(dstream, encoding, startline, startcolumn, 4096);
	}

	public SimpleCharStream(java.io.InputStream dstream, int startline, int startcolumn) {
		this(dstream, startline, startcolumn, 4096);
	}

	public SimpleCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException {
		this(dstream, encoding, 1, 1, 4096);
	}

	public SimpleCharStream(java.io.InputStream dstream) {
		this(dstream, 1, 1, 4096);
	}

	public void ReInit(java.io.InputStream dstream, String encoding, int startline, int startcolumn, int buffersize)
			throws java.io.UnsupportedEncodingException {
		ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream,
				encoding), startline, startcolumn, buffersize);
	}

	public void ReInit(java.io.InputStream dstream, int startline, int startcolumn, int buffersize) {
		ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
	}

	public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException {
		ReInit(dstream, encoding, 1, 1, 4096);
	}

	public void ReInit(java.io.InputStream dstream) {
		ReInit(dstream, 1, 1, 4096);
	}

	public void ReInit(java.io.InputStream dstream, String encoding, int startline, int startcolumn)
			throws java.io.UnsupportedEncodingException {
		ReInit(dstream, encoding, startline, startcolumn, 4096);
	}

	public void ReInit(java.io.InputStream dstream, int startline, int startcolumn) {
		ReInit(dstream, startline, startcolumn, 4096);
	}

	public String GetImage() {
		if (bufpos >= tokenBegin)
			return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
		else
			return new String(buffer, tokenBegin, bufsize - tokenBegin) + new String(buffer, 0, bufpos + 1);
	}

	public char[] GetSuffix(int len) {
		char[] ret = new char[len];

		if ((bufpos + 1) >= len)
			System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
		else {
			System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0, len - bufpos - 1);
			System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
		}

		return ret;
	}

	public void Done() {
		buffer = null;
		bufline = null;
		bufcolumn = null;
	}

	/**
	 * Method to adjust line and column numbers for the start of a token.
	 */
	public void adjustBeginLineColumn(int newLine, int newCol) {
		int start = tokenBegin;
		int len;

		if (bufpos >= tokenBegin) {
			len = bufpos - tokenBegin + inBuf + 1;
		} else {
			len = bufsize - tokenBegin + bufpos + 1 + inBuf;
		}

		int i = 0, j = 0, k = 0;
		int nextColDiff = 0, columnDiff = 0;

		while (i < len && bufline[j = start % bufsize] == bufline[k = ++start % bufsize]) {
			bufline[j] = newLine;
			nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
			bufcolumn[j] = newCol + columnDiff;
			columnDiff = nextColDiff;
			i++;
		}

		if (i < len) {
			bufline[j] = newLine++;
			bufcolumn[j] = newCol + columnDiff;

			while (i++ < len) {
				if (bufline[j = start % bufsize] != bufline[++start % bufsize])
					bufline[j] = newLine++;
				else
					bufline[j] = newLine;
			}
		}

		line = bufline[j];
		column = bufcolumn[j];
	}

}
