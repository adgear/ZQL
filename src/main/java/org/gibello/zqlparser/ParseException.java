/*
 * This file is part of Zql.
 *
 * Zql is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Zql is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Zql.  If not, see http://www.gnu.org/licenses.
 */

/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 3.0 */
package org.gibello.zqlparser;

/**
 * This exception is thrown when parse errors are encountered. You can explicitly create objects of this exception type
 * by calling the method generateParseException in the generated parser. You can modify this class to customize your
 * error reporting mechanisms so long as you retain the public fields.
 * 
 * @author Generated by JavaCC, Automated
 */
public class ParseException extends Exception {

	/**
	 * Hexa magic number.
	 */
	private static final int	MAGIC_NUMBER_HEXA_0X7E	= 0x7e;

	/**
	 * Hexa magic number.
	 */
	private static final int	MAGIC_NUMBER_HEXA_0X20	= 0x20;

	/**
	 * Magic number.
	 */
	private static final int	MAGIC_NUMBER_4			= 4;

	/**
	 * Magic number.
	 */
	private static final int	MAGIC_NUMBER_16			= 16;

	/**
	 * Tab \t.
	 */
	private static final String	TAB_STRING				= "    ";

	/**
	 * Empty space.
	 */
	private static final String	EMPTY_SPACE				= " ";

	/**
	 * 
	 */
	private static final long	serialVersionUID		= 1L;

	/**
	 * This constructor is used by the method "generateParseException" in the generated parser. Calling this constructor
	 * generates a new object of this type with the fields "currentToken", "expectedTokenSequences", and "tokenImage"
	 * set. The boolean flag "specialConstructor" is also set to true to indicate that this constructor was used to
	 * create this object. This constructor calls its super class with the empty string to force the "toString" method
	 * of parent class "Throwable" to print the error message in the form: ParseException: <result of getMessage>.
	 * 
	 * @param currentTokenVal
	 *            the current token value.
	 * @param expectedTokenSequencesVal
	 *            the expected token sequence values.
	 * @param tokenImageVal
	 *            token image value.
	 */
	public ParseException(final Token currentTokenVal, final int[][] expectedTokenSequencesVal,
			final String[] tokenImageVal) {
		super("");
		specialConstructor = true;
		currentToken = currentTokenVal;
		expectedTokenSequences = expectedTokenSequencesVal;
		tokenImage = tokenImageVal;
	}

	/**
	 * The following constructors are for use by you for whatever purpose you can think of. Constructing the exception
	 * in this manner makes the exception behave in the normal way - i.e., as documented in the class "Throwable". The
	 * fields "errorToken", "expectedTokenSequences", and "tokenImage" do not contain relevant information. The JavaCC
	 * generated code does not use these constructors.
	 */

	/**
	 * Default constructor.
	 */
	public ParseException() {
		super();
		specialConstructor = false;
	}

	/**
	 * Constructor with given error message.
	 * 
	 * @param message
	 *            the error message.
	 */
	public ParseException(final String message) {
		super(message);
		specialConstructor = false;
	}

	/**
	 * This variable determines which constructor was used to create this object and thereby affects the semantics of
	 * the "getMessage" method (see below).
	 */
	private boolean		specialConstructor;

	/**
	 * This is the last token that has been consumed successfully. If this object has been created due to a parse error,
	 * the token followng this token will (therefore) be the first error token.
	 */
	private Token		currentToken;

	/**
	 * Each entry in this array is an array of integers. Each array of integers represents a sequence of tokens (by
	 * their ordinal values) that is expected at this point of the parse.
	 */
	private int[][]		expectedTokenSequences;

	/**
	 * This is a reference to the "tokenImage" array of the generated parser within which the parse error occurred. This
	 * array is defined in the generated ...Constants interface.
	 */
	private String[]	tokenImage;

	/**
	 * This method has the standard behavior when this object has been created using the standard constructors.
	 * Otherwise, it uses "currentToken" and "expectedTokenSequences" to generate a parse error message and returns it.
	 * If this object has been created due to a parse error, and you do not catch it (it gets thrown from the parser),
	 * then this method is called during the printing of the final stack trace, and hence the correct error message gets
	 * displayed.
	 * 
	 * @return the error message.
	 */
	public String getMessage() {

		if (!this.specialConstructor) {
			return super.getMessage();
		}
		final StringBuffer expected = new StringBuffer();
		int maxSize = 0;
		for (int i = 0; i < this.expectedTokenSequences.length; i++) {
			if (maxSize < this.expectedTokenSequences[i].length) {
				maxSize = this.expectedTokenSequences[i].length;
			}
			for (int j = 0; j < this.expectedTokenSequences[i].length; j++) {
				expected.append(this.tokenImage[this.expectedTokenSequences[i][j]]).append(ParseException.EMPTY_SPACE);
			}
			if (this.expectedTokenSequences[i][this.expectedTokenSequences[i].length - 1] != 0) {
				expected.append("...");
			}
			expected.append(eol).append(ParseException.TAB_STRING);
		}
		String retval = "Encountered \"";
		Token tok = this.currentToken.getNext();
		for (int i = 0; i < maxSize; i++) {
			if (i != 0) {
				retval += EMPTY_SPACE;
			}
			if (tok.getKind() == 0) {
				retval += this.tokenImage[0];
				break;
			}
			retval += addEscapes(tok.getImage());
			tok = tok.getNext();
		}
		retval += "\" at line " + this.currentToken.getNext().getBeginLine() + ", column "
				+ this.currentToken.getNext().getBeginColumn();
		retval += "." + eol;
		if (this.expectedTokenSequences.length == 1) {
			retval += "Was expecting:" + eol + TAB_STRING;
		} else {
			retval += "Was expecting one of:" + eol + TAB_STRING;
		}
		retval += expected.toString();
		return retval;
	}

	/**
	 * The end of line string for this machine.
	 */
	private String	eol	= System.getProperty("line.separator", "\n");

	/**
	 * Used to convert raw characters to their escaped version when these raw version cannot be used as part of an ASCII
	 * string literal.
	 * 
	 * @param str
	 *            given string of raw characters.
	 * @return the escaped string.
	 */
	protected final String addEscapes(final String str) {
		final StringBuffer retval = new StringBuffer();
		char ch;
		for (int i = 0; i < str.length(); i++) {
			switch (str.charAt(i)) {
				case 0:
					continue;
				case '\b':
					retval.append("\\b");
					continue;
				case '\t':
					retval.append("\\t");
					continue;
				case '\n':
					retval.append("\\n");
					continue;
				case '\f':
					retval.append("\\f");
					continue;
				case '\r':
					retval.append("\\r");
					continue;
				case '\"':
					retval.append("\\\"");
					continue;
				case '\'':
					retval.append("\\\'");
					continue;
				case '\\':
					retval.append("\\\\");
					continue;
				default:
					ch = str.charAt(i);
					if (ch < ParseException.MAGIC_NUMBER_HEXA_0X20 || ch > ParseException.MAGIC_NUMBER_HEXA_0X7E) {
						final String s = "0000" + Integer.toString(ch, ParseException.MAGIC_NUMBER_16);
						retval.append("\\u" + s.substring(s.length() - ParseException.MAGIC_NUMBER_4, s.length()));
					} else {
						retval.append(ch);
					}
					continue;
			}
		}
		return retval.toString();
	}

	/**
	 * @return is special constructor.
	 */
	public boolean isSpecialConstructor() {
		return this.specialConstructor;
	}

	/**
	 * @param specialConstructor
	 *            sets is special constructor.
	 */
	public void setSpecialConstructor(final boolean specialConstructor) {
		this.specialConstructor = specialConstructor;
	}

	/**
	 * Gets current token.
	 * 
	 * @return the current token.
	 */
	public Token getCurrentToken() {
		return this.currentToken;
	}

	/**
	 * Sets the current token.
	 * 
	 * @param currentToken
	 *            the current token to be set.
	 */
	public void setCurrentToken(final Token currentToken) {
		this.currentToken = currentToken;
	}

	/**
	 * Gets the excpected token sequences.
	 * 
	 * @return the expected token sequences.
	 */
	public int[][] getExpectedTokenSequences() {
		return this.expectedTokenSequences;
	}

	/**
	 * Sets the expected token sequences.
	 * 
	 * @param expectedTokenSequences
	 *            the expected token sequences.
	 */
	public void setExpectedTokenSequences(final int[][] expectedTokenSequences) {
		this.expectedTokenSequences = expectedTokenSequences;
	}

	/**
	 * Gets the token image.
	 * 
	 * @return the token image.
	 */
	public String[] getTokenImage() {
		return this.tokenImage;
	}

	/**
	 * Sets the token image.
	 * 
	 * @param tokenImage
	 *            the token image.
	 */
	public void setTokenImage(final String[] tokenImage) {
		this.tokenImage = tokenImage;
	}

	/**
	 * @return the eol
	 */
	public String getEol() {
		return this.eol;
	}

	/**
	 * @param eol
	 *            the eol to set
	 */
	public void setEol(final String eol) {
		this.eol = eol;
	}

}
